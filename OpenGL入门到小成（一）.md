### OpenGL入门

OpenGL可以渲染2D、3D矢量图形，以及在视频、图片中进行的滤镜操作。各种图形API的作用本质就是使用GPU芯片高速渲染图形，得益于GPU的计算能力。而图形API也是iOS唯一接近GPU的地方。

#### 了解OpenGL相关平台

- OpenGL（Open Graphics Library）：用于渲染2D、3D矢量图形的跨平台、跨语言的编程程序的接口集合。
- OpenGL ES （OpenGL for Embedded Systems）：三维图形应用程序OpenGL的子集（去除了glBegin/glEnd，四边形、多边形等复杂图元以及非绝对必要的特性），用于手机、PDA、游戏机等嵌入式设备而设计的编程接口。
- DirectX（Direct eXtension）：由微软公司创建的多媒体、游戏开发的应用程序接口。广泛运用且仅支持在Windows、XBox电子游戏开发。不是跨平台语言，按性质分类为四部分：显示部分，声音部分，输入部分，网络部分。
- Metal：Apple为游戏开发者提供的新平台技术，可以为3D图像提高十倍渲染性能。



#### 了解OpenGL专业名词

为了可以在今后的学习中，可以更加清楚处理过程，必须对其中的专业名词释义进行理解和消化。

##### 上下文(context)

- 在应用程序调用OpenGL任一API之前都会先初始化一个上下文，这是OpenGL的命令基础。因为用来记录OpenGL中的各个对象以及状态，也被称为状态机。

- OpenGL中的函数都是类似C的面向过程的，其本质是通过上下文这个庞大的状态机进行修改某个状态或者某个对象，前提都是需要把对象设为当前对象。通过封装OpenGL函数，可以实现面向对象的图形API。

- 由于上下文是个庞大的状态机，在多个模块的渲染中，可以在不同的线程创建不同的上下文，上下文间共享文理、缓冲区资源等。可以减少上下文的切换和修改渲染状态带来的巨大资源损耗。

- 状态机是理论上的一种的机器。状态机可以说是一种行为，记录了对象在其生命周期内中的各种状态序列，以及状态事件的响应。状态机有以下特点：

  ①有记忆功能，可以记忆当前状态。

  ②可以根据输入的值和之前的值计算后进行修改。

  ③在某些状态（停机）时，无法接收输入，停止工作。

- OpenGL程序退出之前，总是会先停止工作的。

##### 渲染(render)

​	将图像/图像数据转换成3D空间图像的操作。

##### 顶点数组(VertexArray)、顶点缓冲区(VertexBuffer)

​	画图中一般是先画大体架构，在进行填充上色。在OpenGL中也是这样的，绘制的点、线、面等图形都是由顶点构成的，OpenGL中都是由图元组成的，在OpenGL ES中只有三种图元：点、线、三角形。

​	顶点数据存放在内存中，也可以存储在顶点缓冲区中。存放在内存中就是绘制的时候调用绘制函数，传入顶点数据，就会存储在内存中；**性能更高的是先分配一块显存，预先把顶点存到显存中，这一块显存被称为顶点缓冲区。**



##### 管线

​	OpenGL渲染图形中，可以有多个处理单元并行执行加快执行速度，其具体过程类似于工厂中的流水线。

##### 固定管线/存储着色器

​	在早期的版本中，固定管线是封装了许多着色器程序模块，包含了坐标转换、裁切、旋转变换等功能的模块程序，帮助开发者只需调用函数，传入参数即可得到想要的结果。其实可以说是一个封装的接口模块。	

​	因为固定管线/着色器无法一一包含所有实现的功能，这时将相关部分变成可编程的部分。

##### 着色器程序(Shader)

​	全面的将固定管线架构变成了可编程渲染管线。实际在绘制的过程中需要传入一个指定着色器程序的参数。常见的着色器程序有：	

- 顶点着色器(VertexShader)

- 片段着色器(FragmentShader)、像素着色器(PixelShader，DirectX的叫法，这两者描述的是同一个东西)

- 几何着色器(GeomtryShader)

- 曲线细分着色器(TessellationShader)

  

  直至OpenGL ES 3.0还只支持顶点着色器和片段着色器。

  OpenGL在处理着色器时，像普通程序一样经过编译、链接后生成着色器程序(glProgram)。着色器程序同时包含了顶点着色器和片段着色器的运算逻辑。OpenGL在绘制过程如下：

  1. 首先是顶点着色器对传入的顶点数据进行运算。
  2. 通过图元装配，把顶点转换成图元。
  3. 进行光栅化，将图元转成栅格化数据。
  4. 片段着色器将栅格化数据每一个像素进行运算，决定像素的颜色后进行渲染。



##### 顶点着色器(VertexShader)

顶点着色器是Open GL计算顶点属性的程序。

- 处理每个顶点的变换，旋转/平移/投影等。
- 顶点着色器会逐顶点进行并行计算，每个顶点都会计算一次，并且计算每个顶点的时候无法访问其他顶点的数据。
- 一般来说每个顶点进行属性运算包括坐标变换运算、逐顶点光照运算等。从自身坐标系转化成归一化坐标系也是在这里进行的。



##### 片段着色器(FragmentShader)

片段着色器是OpenGL中进行计算每个片段（像素）的颜色和填充的程序。

- 片段着色器主要做的就是计算每个像素的颜色和填充。
- 片段着色器是逐像素进行并行运算的。



##### GLSL

OpenGL 着色语言(Open GL Shadering Language)，用在Open GL着色的编程的语言。是开发人员编写的短小自定义的程序，他们在图形处理单元(Graphic Processor Unit，GPU)中执行。GLSL代替了固定管线的步骤的一部分，变得可以自定义编程，使得固定管线的不同层次具有可编程性。

GLSL的着色器分为两个部分：顶点着色器和片段着色器。



##### 光栅化(Rasterization)

把物体的数学描述和物体相关的颜色信息转换成屏幕上的对应像素和颜色填充，这个过程被称为光栅化。这个过程就是从模拟信号到离散信号的过程，过程产生的就是片元。光栅化就是把顶点数据转换成片元的过程。片元每个元素都对应着帧缓冲区的一个像素。

- 光栅化的本质是把几何图元转换成二位图像的过程。该过程包含两个过程：

  ①决定窗口中哪些整型栅格化区域是被图元占据的

  ②分配一个颜色值和深度到各个区域。



##### 纹理(Texture)

在OpenGL中渲染图形时，有时为了使场景更加逼真，会使用图片编码进行填充(可以理解成贴图)。这个图片在OpenGL中被称为纹理。



##### 混合(Blending)

在测试阶段过后，如果还有像素没有剔除。那么像素的颜色将会和帧缓冲区中颜色附着的颜色进行混合。混合算法可以通过函数进行指定，如果想实现更加复杂的算法，可以通过片段着色器进行计算，但是这样的性能会比原生的混合算法差一些。



##### 变换矩阵(Transformation)

图形发生平移、旋转、缩放就需要用到变换矩阵。



##### 投影矩阵(Projection)

把3D坐标转换成2D坐标，实际的线条也使用二维坐标下进行绘制。



##### 渲染上屏/交换缓冲区(SwrapBuffer)

- 渲染缓冲区一般映射的是系统的资源比如窗口。如果将图像映射到窗口对应的缓冲区，那么图像将会显示到屏幕中。
- 如果窗口只有一个缓冲区，那么在绘制过程中进行了刷新，那么屏幕可能显示不完全的图像。
- 一般的OpenGL程序至少会有两个缓冲区，显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在一个缓冲区渲染完成后，将会交换屏幕缓冲区和离屏缓冲区，已达到图像在屏幕显示的目的。
- 由于显示是逐行进行的，为了避免交换缓冲区的时候两个缓冲区不在同一帧的问题，因此交换一般会等待屏幕刷新完成信号后进行，在刷新间隔中进行交换，技术称为垂直同步，这个信号被称为垂直同步信号。
- 使用了双缓冲和垂直同步的技术，发现每次都要在垂直同步信号后进行渲染下一帧，这样无法让到达硬件允许的帧率。后来引入了三缓冲区技术，在等待垂直同步信号时，来回交换两个离屏缓冲区，在垂直同步信号来时，交换屏幕缓冲区和最近渲染完成的离屏缓冲区。



### OpenGL关于一些视图

##### 视口

视口和视图窗口的大小默认是相等的，也可以单独设置视口的大小，但是一般不这么做。



#### OpenGL投影方式

有两种投影方式：透视投影和正投影。

透视投影：是为了获取3D视觉效果而在二位坐标系中展示的一种方法，也成透视图。

正投影：平行投射线平行于投影面



#### OpenGL坐标系转换全局图

![](https://github.com/oymuzi/OpenGLDocs/raw/master/Resources/坐标转换.png)



#### OpenGL 渲染流程图

![](https://github.com/oymuzi/OpenGLDocs/raw/master/Resources/着色器的渲染过程.jpeg)


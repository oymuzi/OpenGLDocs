### 前言

为了可以在今后的OpenGL/Open GL ES / Metal等学习中，可以更加清楚处理过程，必须对其中的一些专业名词进行理解和消化。

### 常见的基础名词

#### 上下文(context)

- 在应用程序调用OpenGL任一API之前都会先初始化一个上下文，这是OpenGL的命令基础。因为用来记录OpenGL中的各个对象以及状态，也被称为状态机。

- OpenGL中的函数都是类似C的面向过程的，其本质是通过上下文这个庞大的状态机进行修改某个状态或者某个对象，前提都是需要把对象设为当前对象。通过封装OpenGL函数，可以实现面向对象的图形API。

- 由于上下文是个庞大的状态机，在多个模块的渲染中，可以在不同的线程创建不同的上下文，上下文间共享文理、缓冲区资源等。可以减少上下文的切换和修改渲染状态带来的巨大资源损耗。

- 状态机是理论上的一种的机器。状态机可以说是一种行为，记录了对象在其生命周期内中的各种状态序列，以及状态事件的响应。状态机有以下特点：

  ①有记忆功能，可以记忆当前状态。

  ②可以根据输入的值和之前的值计算后进行修改。

  ③在某些状态（停机）时，无法接收输入，停止工作。

- OpenGL程序退出之前，总是会先停止工作的。

#### 渲染(render)

将图像/图像数据转换成3D空间图像的操作。

#### 图元

OpenGL中图形都是由图元组成，而图元则是由顶点组成。在OpenGL中常用有七种图元，在OpenGL ES中只有三种图元：点、线、三角形。

#### 片元

在二位图像中，每个点都含有颜色，深度，纹理信息，将该点和相关信息称为片元。1片元对应着1像素，只是片元含有的信息更多。

#### 顶点数组(VertexArray)

所有图元都是由顶点组成的，有时一个图元由几个点组成，经常会用到顶点数组，保存在内存中或者顶点缓冲区中。

#### 顶点缓冲区(VertexBuffer)

顶点数据存放在内存中，也可以存储在顶点缓冲区中。存放在内存中就是绘制的时候调用绘制函数，传入顶点数据，就会存储在内存中；**性能更高的是先分配一块显存，预先把顶点存到显存中，这一块显存被称为顶点缓冲区。**

#### 管线

OpenGL渲染图形中，可以有多个处理单元并行执行加快执行速度，其具体过程类似于工厂中的流水线。

#### 固定管线/存储着色器

在早期的版本中，固定管线是封装了许多着色器程序模块，包含了坐标转换、裁切、旋转变换等功能的模块程序，帮助开发者只需调用函数，传入指定的着色器程序和其他参数即可得到想要的结果。其实可以说是一个封装的接口模块。	

因为固定管线/着色器无法一一包含所有freestyle的功能，这时将相关部分变成可编程的部分。

#### 着色器程序(Shader)

将固定管线架构的一部分变成了可编程渲染管线。实际在绘制的过程中需要传入一个指定着色器程序的参数。常见的着色器程序有：	

- 顶点着色器(VertexShader)

- 片元着色器(FragmentShader)、像素着色器(PixelShader，DirectX的叫法)、片元着色器(这三种着色器描述的都是同一种着色器，叫法不同)

- 几何着色器(GeomtryShader)

- 曲线细分着色器(TessellationShader)

  

  直至OpenGL ES 3.0还只支持顶点着色器和片段着色器。

  OpenGL在处理着色器时，像普通程序一样经过编译、链接后生成着色器程序(glProgram)。着色器程序同时包含了顶点着色器和片段着色器的运算逻辑。OpenGL在绘制过程如下：

  1. 首先是顶点着色器对传入的顶点数据进行运算。
  2. 通过图元装配，把顶点转换成图元。
  3. 进行光栅化，将图元转成栅格化数据。
  4. 片段着色器将栅格化数据每一个像素进行运算，决定像素的颜色后进行渲染。



#### 顶点着色器(VertexShader)

顶点着色器是Open GL计算顶点属性的程序，包括旋转、平移、缩放等运算。

- 顶点着色器会逐顶点进行并行计算，每个顶点都会计算一次，并且计算每个顶点的时候无法访问其他顶点的数据。
- 一般来说每个顶点进行属性运算包括坐标变换运算、逐顶点光照运算等。从自身坐标系转化成归一化坐标系也是在这里进行的。



#### 片元着色器(FragmentShader)

片段着色器是OpenGL中逐像素进行并行计算每个片段（像素）的颜色和填充的程序，还有别名：**片段着色器、像素着色器。**



#### GLSL

OpenGL 着色语言(Open GL Shadering Language)，用在Open GL着色的编程的语言。是开发人员编写的短小自定义的程序，他们在图形处理单元(Graphic Processor Unit，GPU)中执行。GLSL代替了固定管线的步骤的一部分，变得可以自定义编程，使得固定管线的不同层次具有可编程性。

GLSL的着色器分为两个部分：顶点着色器和片段着色器。



#### 光栅化(Rasterization)

把物体的数学描述和物体相关的颜色信息转换成屏幕上的对应像素和颜色填充，这个过程被称为光栅化。这个过程就是从模拟信号到离散信号的过程，过程产生的就是片元。光栅化就是把顶点数据转换成片元的过程。片元每个元素都对应着帧缓冲区的一个像素。

- 光栅化的本质是把几何图元转换成二维图像的过程。该过程包含两个过程：

  ①决定窗口中哪些整型栅格化区域是被图元占据的

  ②分配一个颜色值和深度到各个区域。



#### 纹理(Texture)

在OpenGL中渲染图形时，有时为了使场景更加逼真，会使用图片编码后进行填充(可以理解成贴图，即每个像素都从图片中获取后进行填充，不再使用单纯的颜色填充）。这个图片在OpenGL中被称为纹理。



#### 混合(Blending)

像素的颜色将会和帧缓冲区中颜色附着的颜色进行混合。混合算法可以通过函数进行指定，如果想实现更加复杂的算法，可以通过片段着色器进行计算，但是这样的性能会比原生的混合算法差一些（排除大牛的手法）。



#### 变换矩阵(Transformation)

[数学线性代数的一个概念](https://zh.wikipedia.org/wiki/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5)。图形发生平移、旋转、缩放就需要用到变换矩阵。



#### 投影矩阵(Projection)

把3D坐标转换成2D坐标，实际的线条也使用二维坐标下进行绘制。



#### 渲染上屏/交换缓冲区(SwrapBuffer)

渲染缓冲区一般映射的是系统的资源比如窗口。如果将图像映射到窗口对应的缓冲区，那么图像将会显示到屏幕中。

- 一般的OpenGL程序至少会有两个缓冲区，显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在一个缓冲区渲染完成后，将会交换屏幕缓冲区和离屏缓冲区，已达到图像在屏幕中很好的显示的目的。如果窗口只有一个缓冲区，那么在绘制过程中进行了刷新，那么屏幕可能显示不完全的图像。
- 由于显示是逐行进行的，为了避免交换缓冲区的时候两个缓冲区不在同一帧的问题，因此交换一般会等待屏幕刷新完成信号后进行，在刷新间隔中进行交换，技术称为垂直同步，这个信号被称为垂直同步信号。
- 使用了双缓冲和垂直同步的技术，发现每次都要在垂直同步信号后进行渲染下一帧，这样无法让到达硬件允许的帧率。后来引入了三缓冲区技术，在等待垂直同步信号时，来回交换两个离屏缓冲区，在垂直同步信号来时，交换屏幕缓冲区和最近渲染完成的离屏缓冲区。



